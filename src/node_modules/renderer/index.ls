require! {
	std
}

{string} = std



class Renderer

	~>

	############################################################################
	# Global rendering
	############################################################################

	render: (input) ->
		# Input arguments processing -------------------------------------------

		# ---------------------------------------------------------------- input

		input ?= {}
		if typeof! input isnt 'Object' => throw {
			msg: '''Input should be an object (describing sections) but it's not'''
			input
		}

		# Processing & return --------------------------------------------------

		@render-section ...

	render-section: (input, level) ->
		# Input arguments processing -------------------------------------------

		# ---------------------------------------------------------------- input
		input ?= {}
		# ---------------------------------------------------------------- level
		level ?= 1

		# Processing -----------------------------------------------------------

		sections = for title, content of input
			section = ''

			section += @section title, level
			section += '\n\n'

			type = typeof! content
			section += switch type
				| 'Object' => @render-section content, level + 1
				| 'Array' => @render-paragraphs content
				| _ => throw {
					msg: 'Unsupported section content type'
					type
					section: title
					content
				}

			section += '\n'

			section

		output = sections.join '\n'

		# Return ---------------------------------------------------------------

		output

	render-paragraphs: (list) ->
		# Input arguments processing -------------------------------------------

		# ----------------------------------------------------------- paragraphs
		list ?= []

		# Processing -----------------------------------------------------------

		paragraphs = for content in list
			type = typeof! content
			switch type
			| 'Array' => @list content
			| 'String' => content
			| _ => throw {
				msg: 'Unsupported content type in paragraphs list'
				type
				content
			}

		output = paragraphs.join '\n\n'

		# Return ---------------------------------------------------------------

		output



	############################################################################
	# Section
	############################################################################

	section: (title, level) -> ...



	############################################################################
	# List
	############################################################################

	list: (list, ordered, level) ->
		# Input arguments processing -------------------------------------------

		# ----------------------------------------------------------------- list
		list ?= []
		# -------------------------------------------------------------- ordered
		ordered ?= no
		# ---------------------------------------------------------------- level
		level ?= 1

		# Processing -----------------------------------------------------------

		parts = for item in list
			type = typeof! item
			switch type
			| 'Array' => @list item, ordered, level + 1
			| 'String', 'Number' => @list-item item, ordered, level
			| _ => throw {
				msg: 'Unsupported list item'
				type
				item
			}

		output = parts.join '\n'

		# Return ---------------------------------------------------------------

		output

	list-item: (text, level, ordered) -> ...



	############################################################################
	# Links
	############################################################################

	url: (url, text, title) -> ...
	link: (page, text, title) -> ...


	############################################################################
	# Emphasis
	############################################################################

	emphase: (text, options) ->
		# Input arguments processing -------------------------------------------

		# ----------------------------------------------------------------- text

		if not text? => throw Error 'No text given'

		# -------------------------------------------------------------- options

		options ?= {+i, +b}

		# Processing -----------------------------------------------------------

		output = text
		{i, b} = options
		if i => output = @italic output
		if b => output = @bold output

		# Return ---------------------------------------------------------------

		output

	italic: (text) ->
		string.surround "#{@emphaseChar}" * @italicX, text

	bold: (text) ->
		string.surround "#{@emphaseChar}" * @boldX, text





std.packager.export {
	module

	values: [
		{
			value: Renderer
			names: <[
				Renderer
			]>
		}
	]
}
